;; 2011-11-24.  temp/examplesarithdickson.scm

;; Based on Josef Berger's final.scm.  Comparison: Lemma1 renamed into
;; Descent lemma.  After decoration its content maps f,g into a boolean
;; (since we are not interested in i,j).  From the Descent lemma DL

;; all f,g,n ex k(I f g n<=k & exu i,j(i<j & j<=k & f i<=f j & g i<=g j))

;; is proved by general induction with measure Phi.  The extracted term
;; gives iterations of I as bound.  The rest is essentially a cleanup:

;; - Relation to the finite pigeon hole principle FPH made explicit.
;; It is used as proved in examples/arith/fph.scm.

;; - Disjunctions (inductively defined) instead of booleans.  This
;; avoids usage of stabilities.

;; - Pair coding made monotonic in both arguments.  Properties of the
;; coding proved by means of component functions.

;; - Totality proofs provided.

;; (load "~/git/minlog/init.scm")

(set! COMMENT-FLAG #f)
(libload "nat.scm")
(set! COMMENT-FLAG #t)

(add-var-name "f" "g" "s" (py "nat=>nat"))
(add-var-name "i" "j" "l" "c" (py "nat"))

(add-program-constant "Mini" (py "(nat=>nat)=>nat=>nat"))
(add-computation-rules
 "Mini f 0" "0"
 "Mini f(Succ n)" "[if (f(Mini f n)<=f(Succ n)) (Mini f n) (Succ n)]")

;; MiniTotal
(set-goal (rename-variables (term-to-totality-formula (pt "Mini"))))
(assume "f^" "Tf" "n^" "Tn")
(elim "Tn")
(use "TotalNatZero")
(assume "n^1" "Tn1" "IH")
(ng #t)
(use "BooleIfTotal")
(use "NatLeTotal")
(use "Tf")
(use "IH")
(use "Tf")
(use "TotalNatSucc")
(use "Tn1")
(use "IH")
(use "TotalNatSucc")
(use "Tn1")
;; Proof finished.
(save "MiniTotal")

(add-program-constant "Maxi" (py "(nat=>nat)=>nat=>nat"))
(add-computation-rules
 "Maxi f 0" "0"
 "Maxi f(Succ n)" "[if (f(Succ n)<=f(Maxi f n)) (Maxi f n) (Succ n)]")

;; "MaxiTotal"
(set-goal (rename-variables (term-to-totality-formula (pt "Maxi"))))
(assume "f^" "Tf" "n^" "Tn")
(elim "Tn")
(use "TotalNatZero")
(assume "n^1" "Tn1" "IH")
(ng #t)
(use "BooleIfTotal")
(use "NatLeTotal")
(use "Tf")
(use "TotalNatSucc")
(use "Tn1")
(use "Tf")
(use "IH")
(use "IH")
(use "TotalNatSucc")
(use "Tn1")
;; Proof finished.
(save "MaxiTotal")

(add-program-constant "Psi" (py "(nat=>nat)=>(nat=>nat)=>nat=>nat"))
(add-computation-rule "Psi f g n" "f(Mini g n)max g(Mini f n)")

;; "PsiTotal"
(set-goal (rename-variables (term-to-totality-formula (pt "Psi"))))
(assume "f^" "Tf" "g^" "Tg" "n^" "Tn")
(use "NatMaxTotal")
(use "Tf")
(use "MiniTotal")
(use "Tg")
(use "Tn")
(use "Tg")
(use "MiniTotal")
(use "Tf")
(use "Tn")
;; Proof finished.
(save "PsiTotal")

(add-program-constant "I" (py "(nat=>nat)=>(nat=>nat)=>nat=>nat"))
(add-computation-rule "I f g n" "Succ(n+Psi f g n*Psi f g n)")

;; "ITotal"
(set-goal (rename-variables (term-to-totality-formula (pt "I"))))
(assume "f^" "Tf" "g^" "Tg" "n^" "Tn")
(use "TotalNatSucc")
(use "NatPlusTotal")
(use "Tn")
(use "NatTimesTotal")
(use "NatMaxTotal")
(use "Tf")
(use "MiniTotal")
(use "Tg")
(use "Tn")
(use "Tg")
(use "MiniTotal")
(use "Tf")
(use "Tn")

(use "NatMaxTotal")
(use "Tf")
(use "MiniTotal")
(use "Tg")
(use "Tn")
(use "Tg")
(use "MiniTotal")
(use "Tf")
(use "Tn")
;; Proof finished.
(save "ITotal")

(add-program-constant "ItI" (py "(nat=>nat)=>(nat=>nat)=>nat=>nat=>nat"))
(add-computation-rules
 "ItI f g 0 n" "n"
 "ItI f g(Succ m)n" "I f g(ItI f g m n)")

;; "ItITotal"
(set-goal (rename-variables (term-to-totality-formula (pt "ItI"))))
(assume "f^" "Tf" "g^" "Tg" "m^" "Tm" "n^" "Tn")
(elim "Tm")
(use "Tn")
(assume "n^1" "Tn1" "IH")
(use "ITotal")
(use "Tf")
(use "Tg")
(use "IH")
;; Proof finished.
(save "ItITotal")

(add-program-constant "Phi" (py "(nat=>nat)=>(nat=>nat)=>nat=>nat"))
(add-computation-rule "Phi f g n" "f(Mini f n)+g(Mini g n)")

;; "PhiTotal"
(set-goal (rename-variables (term-to-totality-formula (pt "Phi"))))
(assume "f^" "Tf" "g^" "Tg" "n^" "Tn")
(use "NatPlusTotal")
(use "Tf")
(use "MiniTotal")
(use "Tf")
(use "Tn")
(use "Tg")
(use "MiniTotal")
(use "Tg")
(use "Tn")
;; Proof finished.
(save "PhiTotal")

;; V n is the integer square root of n

(add-program-constant "V" (py "nat=>nat"))
(add-computation-rules
 "V 0" "0"
 "V(Succ n)" "[if (n<Succ(V n)*V n+V n) (V n) (Succ(V n))]")

(set-goal (rename-variables (term-to-totality-formula (pt "V"))))
(use "AllTotalElim")
(ind)
;; Base
(ng #t)
(use "TotalNatZero")
;; Step
(assume "n" "IH")
(ng #t)
(use "BooleIfTotal")
(use "NatLtTotal")
(use "NatTotalVar")
(use "NatPlusTotal")
(use "NatTimesTotal")
(use "TotalNatSucc")
(use "IH")
(use "IH")
(use "IH")
(use "IH")
(use "TotalNatSucc")
(use "IH")
;; Proof finished.
(save "VTotal")

;; Code of pairs of natural numbers

;;  12  13  14  15
;;   6   7   8  11
;;   2   3   5  10
;;   0   1   4   9  16

(add-program-constant "Code" (py "nat=>nat=>nat"))
(add-computation-rules "Code n m" "[if (m<n) (n*n+m) (m*m+m+n)]")

(set-goal (rename-variables (term-to-totality-formula (pt "Code"))))
(use "AllTotalElim")
(assume "n")
(use "AllTotalElim")
(assume "m")
(ng #t)
(use "BooleIfTotal")
(use "BooleTotalVar")
(use "NatTotalVar")
(use "NatTotalVar")
;; Proof finished.
(save "CodeTotal")

;; L is the left component of a coded pair.

(add-program-constant "L" (py "nat=>nat"))
(add-computation-rules "L c" "[if (c<V c*V c+V c) (V c) (c--(V c*V c+V c))]")

(set-goal (rename-variables (term-to-totality-formula (pt "L"))))
(use "AllTotalElim")
(ng #t)
(assume "n")
(use "BooleIfTotal")
(use "BooleTotalVar")
(use "NatTotalVar")
(use "NatTotalVar")
;; Proof finished.
(save "LTotal")

(add-program-constant "R" (py "nat=>nat"))
(add-computation-rules "R c" "[if (c<V c*V c+V c) (c--V c*V c) (V c)]")

(set-goal (rename-variables (term-to-totality-formula (pt "R"))))
(use "AllTotalElim")
(assume "n")
(ng)
(use "BooleIfTotal")
(use "BooleTotalVar")
(use "NatTotalVar")
(use "NatTotalVar")
;; Proof finished.
(save "RTotal")

;; VProp1
(set-goal "all c(V c*V c<=c & c<=V c*V c+V c+V c)")
(ind)
(split)
(use "Truth")
(use "Truth")
(assume "c" "IH")
(split)
(ng #t)
(cases (pt "c<V c*V c+V c+V c"))
(assume "c<V c*V c+V c+V c")
(ng #t)
(use "NatLeTrans" (pt "c"))
(use "IH")
(use "Truth")
(assume "c<V c*V c+V c+V c -> F")
(ng #t)
(use "NatNotLtToLe")
(use "c<V c*V c+V c+V c -> F")
(ng #t)
(cases (pt "c<V c*V c+V c+V c"))
(assume "c<V c*V c+V c+V c")
(ng #t)
(use "NatLtToSuccLe")
(use "c<V c*V c+V c+V c")
(assume "c<V c*V c+V c+V c -> F")
(ng #t)
(use "NatLeTrans" (pt "Succ(V c*V c+V c+V c+V c+V c)"))
(use "NatLeTrans" (pt "V c*V c+V c+V c+V c+V c"))
(use "NatLeTrans" (pt "V c*V c+V c+V c+V c"))
(use "NatLeTrans" (pt "V c*V c+V c+V c"))
(use "IH")
(use "Truth")
(use "Truth")
(use "Truth")
(use "Truth")
;; Proof finished.
(save "VProp1")

;; VProp2
(set-goal "all k,c(k*k<=c -> c<=k*k+k+k -> k=V c)")
(assume "k" "c" "k*k<=c" "c<=k*k+k+k")
(use "NatLeAntiSym")
(use "NatNotLtToLe")
(assume "V c<k")
(assert "(V c+1)*(V c+1)<(V c+1)*(V c+1)")
  (use "NatLeLtTrans" (pt "c"))
  (use "NatLeTrans" (pt "k*k"))
  (use "NatLeMonTimes")
  (use "NatLtToSuccLe")
  (use "V c<k")
  (use "NatLtToSuccLe")
  (use "V c<k")
  (use "k*k<=c")
  (ng #t)
  (use "NatLeToLtSucc")
  (use "VProp1")
(assume "Absurd")
(use "Absurd")

(use "NatNotLtToLe")
(assume "k<V c")
(assert "(k+1)*(k+1)<(k+1)*(k+1)")
  (use "NatLeLtTrans" (pt "c"))
  (use "NatLeTrans" (pt "V c*V c"))
  (use "NatLeMonTimes")
  (use "NatLtToSuccLe")
  (use "k<V c")
  (use "NatLtToSuccLe")
  (use "k<V c")
  (use "VProp1")
  (ng #t)
  (use "NatLeToLtSucc")
  (use "c<=k*k+k+k")
(assume "Absurd")
(use "Absurd")
;; Proof finished.
(save "VProp2")

;; LProp
(set-goal "all n,m L(Code n m)=n")
(assume "n" "m")
(cut "all c(c=Code n m -> L c=n)")
 (assume "Hyp")
 (inst-with-to "Hyp" (pt "Code n m") "HypInst")
 (use "HypInst")
 (use "Truth")
(assume "c" "cDef")
(cases (pt "m<n"))
;; Case m<n
(assume "m<n")
(assert "c=n*n+m")
 (simp "cDef")
 (ng #t)
 (simp "m<n")
 (use "Truth")
(assume "c=n*n+m")

(assert "n=V c")
 (use "VProp2")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n")
 (use "Truth")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n")
 (ng #t)
 (use "NatLeTrans" (pt "n*n+n"))
 (use "NatLeMonPlus")
 (use "Truth")
 (use "NatLtToLe")
 (use "m<n")
 (use "Truth")
(assume "n=V c")

(ng #t)
(simp "<-" "n=V c")
(assert "c<n*n+n")
 (simp "c=n*n+m")
 (use "NatLtMonPlus2")
 (use "Truth")
 (use "m<n")
(assume "c<n*n+n")
(simp "c<n*n+n")
(use "Truth")

;; Case m<n -> F
(assume "m<n -> F")
(assert "c=m*m+m+n")
 (simp "cDef")
 (ng #t)
 (simp "m<n -> F")
 (use "Truth")
(assume "c=m*m+m+n")

(assert "m=V c")
 (use "VProp2")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n -> F")
 (ng #t)
 (use "NatLeTrans" (pt "m*m+m"))
 (use "Truth")
 (use "Truth")
 (simp "c=m*m+m+n")
 (use "NatLeMonPlus")
 (use "Truth")
 (use "NatNotLtToLe")
 (use "m<n -> F")
(assume "m=V c")

(ng #t)
(simp "<-" "m=V c")
(assert "c<m*m+m -> F")
 (simp "c=m*m+m+n")
 (assume "m*m+m+n<m*m+m")
 (assert "m*m+m<m*m+m")
  (use "NatLeLtTrans" (pt "m*m+m+n"))
  (use "Truth")
  (use "m*m+m+n<m*m+m")
 (assume "Absurd")
 (use "Absurd")
(assume "c<m*m+m -> F")
(simp "c<m*m+m -> F")
(ng #t)
(simp "c=m*m+m+n")
(ng #t)
(use "Truth")
;; Proof finished.
(save "LProp")

;; RProp
(set-goal "all n,m R(Code n m)=m")
(assume "n" "m")
(cut "all c(c=Code n m -> R c=m)")
 (assume "Hyp")
 (inst-with-to "Hyp" (pt "Code n m") "HypInst")
 (use "HypInst")
 (use "Truth")
(assume "c" "cDef")
(cases (pt "m<n"))
;; Case m<n
(assume "m<n")
(assert "c=n*n+m")
 (simp "cDef")
 (ng #t)
 (simp "m<n")
 (use "Truth")
(assume "c=n*n+m")

(assert "n=V c")
 (use "VProp2")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n")
 (use "Truth")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n")
 (ng #t)
 (use "NatLeTrans" (pt "n*n+n"))
 (use "NatLeMonPlus")
 (use "Truth")
 (use "NatLtToLe")
 (use "m<n")
 (use "Truth")
(assume "n=V c")

(ng #t)
(simp "<-" "n=V c")
(assert "c<n*n+n")
 (simp "c=n*n+m")
 (use "NatLtMonPlus2")
 (use "Truth")
 (use "m<n")
(assume "c<n*n+n")
(simp "c<n*n+n")
(simp "c=n*n+m")
(use "Truth")

;; Case m<n -> F
(assume "m<n -> F")
(assert "c=m*m+m+n")
 (simp "cDef")
 (ng #t)
 (simp "m<n -> F")
 (use "Truth")
(assume "c=m*m+m+n")

(assert "m=V c")
 (use "VProp2")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n -> F")
 (ng #t)
 (use "NatLeTrans" (pt "m*m+m"))
 (use "Truth")
 (use "Truth")
 (simp "c=m*m+m+n")
 (use "NatLeMonPlus")
 (use "Truth")
 (use "NatNotLtToLe")
 (use "m<n -> F")
(assume "m=V c")

(ng #t)
(simp "<-" "m=V c")
(assert "c<m*m+m -> F")
 (simp "c=m*m+m+n")
 (assume "m*m+m+n<m*m+m")
 (assert "m*m+m<m*m+m")
  (use "NatLeLtTrans" (pt "m*m+m+n"))
  (use "Truth")
  (use "m*m+m+n<m*m+m")
 (assume "Absurd")
 (use "Absurd")
(assume "c<m*m+m -> F")
(simp "c<m*m+m -> F")
(use "Truth")
;; Proof finished.
(save "RProp")

;; CodeSurj
(set-goal "all c Code(L c)(R c)=c")
(assume "c")
(cut "all n,m(n=L c -> m=R c -> Code n m=c)")
 (assume "Hyp")
 (inst-with-to "Hyp" (pt "L c") "HypInst")
 (inst-with-to "HypInst" (pt "R c") "HypInstInst")
 (use "HypInstInst")
 (use "Truth")
 (use "Truth")
(assume "n" "m" "n=L c" "m=R c")
(ng "n=L c" "m=R c")
(cases (pt "c<V c*V c+V c"))
;; Case c<V c*V c+V c
(assume "c<V c*V c+V c")
(simphyp-with-to "n=L c" "c<V c*V c+V c" "n=V c")
(ng "n=V c")
(simphyp-with-to "m=R c" "c<V c*V c+V c" "m=c--V c*V c")
(ng "m=c--V c*V c")
(drop "n=L c" "m=R c")

(assert "all nat1,nat2,nat3(nat1+nat3<nat2+nat3 -> nat1<nat2)")
 (assume "nat1" "nat2")
 (ind)
 ;; Base
 (assume "Hyp")
 (use "Hyp")
 ;; Step
 (assume "nat3" "IH" "Hyp")
 (use "IH")
 (use "Hyp")
(assume "NatLtMonPlusRev")

(assert "c--V c*V c<V c")
 (use "NatLtMonPlusRev" (pt "V c*V c"))
 (assert "c--V c*V c+V c*V c=c")
  (use "NatMinusPlusEq")
  (use "VProp1")
 (assume "EqHyp")
 (simp "EqHyp")
 (simp "NatPlusComm")
 (use "c<V c*V c+V c")
(assume "c--V c*V c<V c")
(assert "m<n")
 (simp "n=V c")
 (simp "m=c--V c*V c")
 (use "c--V c*V c<V c")
(assume "m<n")
(ng #t)
(simp "m<n")
(ng #t)
(simp "n=V c")
(simp "m=c--V c*V c")
(ng #t)
(simp "NatPlusMinus")
(use "Truth")
(use "VProp1")

;; Case "c<V c*V c+V c -> F"
(assume "c<V c*V c+V c -> F")
(simphyp-with-to "n=L c" "c<V c*V c+V c -> F" "n=c--(V c*V c+V c)")
(ng "n=c--(V c*V c+V c)")
(simphyp-with-to "m=R c" "c<V c*V c+V c -> F" "m=V c")
(ng "m=V c")
(drop "n=L c" "m=R c")

(assert "c--(V c*V c+V c)<=V c")
 (assert "c--(V c*V c+V c)<=V c*V c+V c+V c--(V c*V c+V c)")
 (use "NatLeMonMinus")
 (use "VProp1")
 (use "Truth")
(assume "c-(k*k+k)<=k")
(ng "c-(k*k+k)<=k")
(use "c-(k*k+k)<=k")
(assume "c-(k*k+k)<=k")
(assert "m<n -> F")
 (simp "m=V c")
 (simp "n=c--(V c*V c+V c)")
 (assume "k<c-(k*k+k)")
 (assert "V c<V c")
  (use "NatLtLeTrans" (pt "c--(V c*V c+V c)"))
  (use "k<c-(k*k+k)")
  (use "c-(k*k+k)<=k")
 (assume "Absurd")
 (use "Absurd")
(assume "m<n -> F")
(ng #t)
(simp "m<n -> F")
(simp "m=V c")
(simp "n=c--(V c*V c+V c)")
(ng #t)
(simp "NatPlusMinus")
(use "Truth")
(use "NatNotLtToLe")
(use "c<V c*V c+V c -> F")
;; Proof finished.
(save "CodeSurj")

;; CodeInj1
(set-goal "all n1,n2,m1,m2(Code n1 m1=Code n2 m2 -> n1=n2)")
(assume "n1" "n2" "m1" "m2" "c1=c2")
(assert "L(Code n1 m1)=L(Code n2 m2)")
 (simp "c1=c2")
 (use "Truth")
 (simp "LProp")
 (simp "LProp")
(assume "n1=n2")
(use "n1=n2")
;; Proof finished.
(save "CodeInj1")

;; CodeInj2
(set-goal "all n1,n2,m1,m2(Code n1 m1=Code n2 m2 -> m1=m2)")
(assume "n1" "n2" "m1" "m2" "c1=c2")
(assert "R(Code n1 m1)=R(Code n2 m2)")
 (simp "c1=c2")
 (use "Truth")
 (simp "RProp")
 (simp "RProp")
(assume "m1=m2")
(use "m1=m2")
;; Proof finished.
(save "CodeInj2")

;; CodeProp1
(set-goal "all n,m,l(l=n max m ->  Code n m<Succ l*Succ l)")
(assume "n" "m" "l" "EqHyp")
(ng #t)
(cases (pt "m<n"))
;; Case "m<n"
(ng #t)
(assume "m<n") ;will not be used.
(use "NatLeLtTrans" (pt "n*n+l"))
(simp "EqHyp")
(use "NatLeMonPlus")
(use "Truth")
(use "NatMaxUB2")
(use "NatLeLtTrans" (pt "l*l+l"))
(use "NatLeMonPlus")
(use "NatLeMonTimes")
(simp "EqHyp")
(use "NatMaxUB1")
(simp "EqHyp")
(use "NatMaxUB1")
(use "Truth")
(use "NatLeToLtSucc")
(use "Truth")
;; Case "m<n -> F"
(assume "m<n -> F")
(ng #t)
(use "NatLeLtTrans" (pt "m*m+m+l"))
(simp "EqHyp")
(use "NatLeMonPlus")
(use "Truth")
(use "NatMaxUB1")
(use "NatLeLtTrans" (pt "l*l+l+l"))
(use "NatLeMonPlus")
(use "NatLeMonPlus")
(use "NatLeMonTimes")
(simp "EqHyp")
(use "NatMaxUB2")
(simp "EqHyp")
(use "NatMaxUB2")
(simp "EqHyp")
(use "NatMaxUB2")
(use "Truth")
(use "NatLeToLtSucc")
(use "Truth")
;; Proof finished.
(save "CodeProp1")

;; "CodeProp2" ;; not used.
(set-goal "all n,m,l(l=n max m ->  l*l<=Code n m)")
(assume "n" "m" "l" "l=n max m")
(ng #t)
(assert "all nat1,nat2(nat1 max nat2=nat1 ori nat1 max nat2=nat2)")
 (ind)
 ;; Base
 (assume "nat2")
 (intro 1)
 (use "Truth-Axiom")
 ;; Step
 (assume "nat1" "IH")
 (cases)
 (intro 0)
 (use "Truth-Axiom")
 (use "IH")
(assume "NatMaxOr")
(cases (pt "m<n"))
;; Case "m<n"
(ng #t)
(assume "m<n")
(assert "n max m=n ori n max m=m")
 (use "NatMaxOr")
(assume "Disj")
(elim "Disj")
(assume "n max m=n")
(simp "l=n max m")
(simp "n max m=n")
(use "Truth")
(assume "n max m=m")
(simp "l=n max m")
(simp "n max m=m")
(use "NatLeTrans" (pt "n*n"))
(use "NatLeMonTimes")
(use "NatLtToLe")
(use "m<n")
(use "NatLtToLe")
(use "m<n")
(use "Truth")
;; Case "m<n -> F"
(assume "m<n -> F")
(ng #t)
(assert "n max m=n ori n max m=m")
 (use "NatMaxOr")
(assume "Disj")
(elim "Disj")
(assume "n max m=n")
(simp "l=n max m")
(simp "n max m=n")
(assert "n<=m")
 (use "NatNotLtToLe")
 (use "m<n -> F")
(assume "n<=m")
(use "NatLeTrans" (pt "m*m"))
(use "NatLeMonTimes")
(use "n<=m")
(use "n<=m")
(use "NatLeTrans" (pt "m*m+m"))
(use "Truth")
(use "Truth")
(assume "n max m=m")
(simp "l=n max m")
(simp "n max m=m")
(use "NatLeTrans" (pt "m*m+m"))
(use "Truth")
(use "Truth")
;; Proof finished.
(save "CodeProp2")

;; "CodeProp"
(set-goal "all n,m,k(k*k<=Code n m -> k<=n ori k<=m)")
(assume "n" "m" "k")
(assert "all nat1,nat2(nat1 max nat2=nat1 ori nat1 max nat2=nat2)")
 (ind)
 ;; Base
 (assume "nat2")
 (intro 1)
 (use "Truth-Axiom")
 ;; Step
 (assume "nat1" "IH")
 (cases)
 (intro 0)
 (use "Truth-Axiom")
 (use "IH")
(assume "NatMaxOr")
(cut "all l(l=n max m -> k*k<=Code n m -> k<=n ori k<=m)")
 (assume "Hyp")
 (use "Hyp" (pt "n max m"))
 (use "Truth")
(assume "l" "l=n max m" "LeHyp")
(cut "k<=l")
 (assert "n max m=n ori n max m=m")
  (use "NatMaxOr")
 (assume "Disj")
 (elim "Disj")

 (assume "n max m=n")
 (simp "l=n max m")
 (simp "n max m=n")
 (assume "k<=n")
 (intro 0)
 (use "k<=n")

 (assume "n max m=m")
 (simp "l=n max m")
 (simp "n max m=m")
 (assume "k<=m")
 (intro 1)
 (use "k<=m")

;; ?_9: k<=l
(use "NatNotLtToLe")
(assume "l<k")
(cut "k*k<k*k")
 (assume "Absurd")
 (use "Absurd")
(use "NatLeLtTrans" (pt "Code n m"))
(use "LeHyp")
(use "NatLtLeTrans" (pt "Succ l*Succ l"))
(use "CodeProp1")
(use "l=n max m")
(use "NatLeMonTimes")
(use "NatLtToSuccLe")
(use "l<k")
(use "NatLtToSuccLe")
(use "l<k")
;; Proof finished.
(save "CodeProp")

;; Mini1
(set-goal "all f,n Mini f n<=n")
(assume "f")
(ind)
(use "Truth")
(assume "n" "IH")
(cases (pt "f(Mini f n)<=f(Succ n)"))
(assume "LeCase")
(simp "LeCase")
(use "NatLeTrans" (pt "n"))
(use "IH")
(use "Truth")
(assume "NotLeCase")
(simp "NotLeCase")
(use "Truth")
;; Proof finished.
(save "Mini1")

;; "Mini2"
(set-goal "all f,n f(Mini f(Succ n))<=f(Mini f n)")
(assume "f" "n")
(cases (pt "f(Mini f n)<=f(Succ n)"))
(assume "LeCase")
(simp "LeCase")
(use "Truth")
(assume "NotLeCase")
(simp "NotLeCase")
(use "NatLtToLe")
(use "NatNotLeToLt")
(use "NotLeCase")
;; Proof finished.
(save "Mini2")

;; Mini3
(set-goal "all f,n(f(Mini f n)<=f n)")
(assume "f")
(cases)
(use "Truth")
(assume "n")
(cases (pt "f(Mini f n)<=f(Succ n)"))
(assume "LeCase")
(simp "LeCase")
(use "LeCase")
(assume "NotLeCase")
(simp "NotLeCase")
(use "Truth")
;; Proof finished.
(save "Mini3")

;; "fMiniAntiMon"
(set-goal (pf "all f,n,m(n<=m -> f(Mini f m)<=f(Mini f n))"))
(assume "f" "n")
(ind)
;; Base m=0
(assume "n<=0")
(assert (pf "n=0"))
 (use "n<=0")
(assume "n=0")
(simp "n=0")
(use "Truth")
;; m->m+1
(assume "m" "IH")
(assume "n<=Sm")
(use "NatLeCases" (pt "Succ m") (pt "n"))
(use "n<=Sm")
(drop "n<=Sm")
(assume "n<Sm")
(use "NatLeTrans" (pt "f(Mini f m)"))
(use "Mini2")
(use "IH")
(use "NatLtSuccToLe")
(use "n<Sm")
(assume "n=Sm")
(simp "n=Sm")
(use "Truth")
;; Proof finished.
(save "fMiniAntiMon")

;; Maxi1
(set-goal "all f,n Maxi f n<=n")
(assume "f")
(ind)
(use "Truth")
(assume "n" "IH")
(cases (pt "f(Succ n)<=f(Maxi f n)"))
(assume "LeCase")
(simp "LeCase")
(use "NatLeTrans" (pt "n"))
(use "IH")
(use "Truth")
(assume "NotLeCase")
(simp "NotLeCase")
(use "Truth")
;; Proof faxished.
(save "Maxi1")

;; Maxi2
(set-goal "all f,n f(Maxi f n)<=f(Maxi f(Succ n))")
(assume "f" "n")
(cases (pt "f(Succ n)<=f(Maxi f n)"))
(assume "LeCase")
(simp "LeCase")
(use "Truth")
(assume "NotLeCase")
(simp "NotLeCase")
(use "NatLtToLe")
(use "NatNotLeToLt")
(use "NotLeCase")
;; Proof finished.
(save "Maxi2")

;; Maxi3
(set-goal "all f,n f n<=f(Maxi f n)")
(assume "f")
(cases)
(use "Truth")
(assume "n")
(cases (pt "f(Succ n)<=f(Maxi f n)"))
(assume "LeCase")
(simp "LeCase")
(use "LeCase")
(assume "NotLeCase")
(simp "NotLeCase")
(use "Truth")
;; Proof finished.
(save "Maxi3")

;; "Maxi4"
(set-goal "all f,n,i(i<=n -> f i<=f(Maxi f n))")
(assume "f")
(ind)
;; Base
(cases)
(assume "Useless")
(use "Truth")
(assume "n")
(ng)
(use "Efq")
;; Step
(assume "n" "IH")
(assume "i" "i<=n+1")
(use "NatLtSuccCases" (pt "Succ n") (pt "i"))
(use "NatLeLtTrans" (pt "Succ n"))
(use "i<=n+1")
(use "Truth")
(assume "i<n+1")
(use "NatLeTrans" (pt "f(Maxi f n)"))
(use "IH")
(use "NatLtSuccToLe")
(use "i<n+1")
(use "Maxi2")
(assume "i=n+1")
(simp "i=n+1")
(use "Maxi3")
;; Proof finished.
(save "Maxi4")

;; PhiAntiMon
(set-goal (pf "all f,g,n,m(n<=m -> Phi f g m<=Phi f g n)"))
(assume "f" "g" "n" "m" "n<=m")
(use "NatLeMonPlus")
(use "fMiniAntiMon")
(use "n<=m")
(use "fMiniAntiMon")
(use "n<=m")
;; Proof finished.
(save "PhiAntiMon")

;; "LeIncrI"
(set-goal "all f,g,n n<=I f g n")
(assume "f" "g" "n")
(use "NatLeTrans" (pt "Succ n"))
(use "Truth")
(use "Truth")
;; Proof finished.
(save "LeIncrI")

;; LeMonItI
(set-goal "all f,g,n ItI f g n 0<=ItI f g(Succ n)0")
(assume "f" "g" "n")
(use "NatLeTrans" (pt "I f g(ItI f g n 0)"))
(use "LeIncrI")
(use "Truth")
;; Proof finished.
(save "LeMonItI")

;; The following finite pigeon hole principle is proved in
;; examples/arith/fph.scm
(add-global-assumption
 "FPH" (pf "all m,s(all i(i<=Succ m -> s i<=m) ->
                    ex i,j(i<j & j<=Succ m & s i=s j))"))

;; FPHDisj
(set-goal "all s,m(ex i,j(i<j & j<=m & s i=s j) ori ex j(j<=m & m<=s j))")
(assume "s")
(cases)
;; Case m=0.
(intro 1)
(ex-intro (pt "0"))
(split)
(use "Truth")
(use "Truth")
;; Case m+1
(assume "m")
(cut "all j(j=Maxi s(Succ m) ->
       ex i,j(i<j & j<=Succ m & s i=s j) ord ex j(j<=Succ m & Succ m<=s j))")
 (assume "CutHyp")
 (use "CutHyp" (pt "Maxi s(Succ m)"))
 (use "Truth")
(assume "j" "jDef")
(cases (pt "s j<Succ m"))
;; Case "s j<Succ m"
(assume "s j<Succ m")
(intro 0)
(use "FPH")
(assume "i" "i<m+1")
(use "NatLeTrans" (pt "s j"))
(simp "jDef")

(use "Maxi4")
(use "i<m+1")
(use "NatLtSuccToLe")
(use "s j<Succ m")
;; Case "s j<Succ m -> F"
(assume "s j<Succ m -> F")
(intro 1)
(ex-intro (pt "j"))
(split)
(simp "jDef")
(use "Maxi1")
(use "NatNotLtToLe")
(use "s j<Succ m -> F")
;; Proof finished.
(save "FPHDisj")

;; FPHDisjTwo
(set-goal "all f,g,k(
 exu i,j(i<j & j<=k*k & f i = f j & g i = g j) ori
 ex j(j<=k*k & k<=f j)  ori
 ex j(j<=k*k & k<=g j))")
(assume "f" "g" "k")
(inst-with-to "FPHDisj" (pt "[i]Code(f i)(g i)") (pt "k*k") "FPHDisjInst")
(elim "FPHDisjInst")
;; First case
(drop "FPHDisjInst")
(assume "ExHyp")
(by-assume "ExHyp" "i" "iProp")
(by-assume "iProp" "j" "ijProp")
(intro 0)
(intro 0 (pt "i"))
(intro 0 (pt "j"))
(assert "Code(f i)(g i)=Code(f j)(g j)")
 (use "ijProp")
(assume "ci=cj")
(msplit)
(use "CodeInj2" (pt "f i") (pt "f j"))
(use "ci=cj")
(use "CodeInj1" (pt "g i") (pt "g j"))
(use "ci=cj")
(use "ijProp")
(use "ijProp")
;; Second case
(drop "FPHDisjInst")
(assume "ExHyp")
(by-assume "ExHyp" "j" "jProp")
(intro 1)
(assert "k*k<=Code(f j)(g j)")
 (use "jProp")
(assume "k*k<=c")
(assert "k<=f j oru k<=g j")
 (use "CodeProp")
 (use "k*k<=c")
(assume "Disj")
(elim "Disj")

(assume "k<=f j")
(intro 0)
(ex-intro (pt "j"))
(split)
(use "jProp")
(use "k<=f j")

(assume "k<=g j")
(intro 1)
(ex-intro (pt "j"))
(split)
(use "jProp")
(use "k<=g j")
;; Proof finished.
(save "FPHDisjTwo")

;; Key
(set-goal "all f,g,n,k(
 exu i,j(n<i & i<j & j<=Succ n+k*k & f i = f j & g i = g j) ori
 ex j(n<j & j<=Succ n+k*k & k<=f j)  ori
 ex j(n<j & j<=Succ n+k*k & k<=g j))")
(assume "f" "g" "n" "k")
(inst-with-to
 "FPHDisjTwo" (pt "[i]f(Succ n+i)") (pt "[i]g(Succ n+i)") (pt "k")
 "FPHInst")
(elim "FPHInst")
;; First case
(drop "FPHInst")
(assume "ExHyp")
(intro 0)
(by-assume "ExHyp" "i" "iProp")
(by-assume "iProp" "j" "ijProp")
(intro 0 (pt "Succ n+i"))
(intro 0 (pt "Succ n+j"))
(msplit)
(use "ijProp")
(use "ijProp")
(use "NatLeMonPlus")
(use "Truth")
(use "ijProp")
(use "NatLtMonPlus2")
(use "Truth")
(use "ijProp")
(use "NatLeToLtSucc")
(use "Truth")
;; Second or third case
(drop "FPHInst")
(assume "Disj")
(intro 1)
(elim "Disj")
;; Second case
(drop "Disj")
(assume "ExHyp")
(intro 0)
(by-assume "ExHyp" "j" "jProp")
(ex-intro (pt "Succ n+j"))
(msplit)
(use "jProp")
(use "NatLeMonPlus")
(use "Truth")
(use "jProp")
(use "NatLeToLtSucc")
(use "Truth")
;; Third case
(drop "Disj")
(assume "ExHyp")
(intro 1)
(by-assume "ExHyp" "j" "jProp")
(ex-intro (pt "Succ n+j"))
(msplit)
(use "jProp")
(use "NatLeMonPlus")
(use "Truth")
(use "jProp")
(use "NatLeToLtSucc")
(use "Truth")
;; Proof finished.
(save "Key")

;; Desc
(set-goal "all f,g,n(
 exu i,j(i<j & j<=I f g n & f i<=f j & g i<=g j) ori
 Phi f g(I f g n)<Phi f g n)")
(assume "f" "g" "n")
(inst-with-to "Key" (pt "f") (pt "g") (pt "n") (pt "Psi f g n") "KeyInst")
(elim "KeyInst")
;; First case
(drop "KeyInst")
(assume "ExHyp")
(intro 0)
(by-assume "ExHyp" "i" "iProp")
(by-assume "iProp" "j" "ijProp")
(intro 0 (pt "i"))
(intro 0 (pt "j"))
(msplit)
(simp "ijProp")
(use "Truth")
(simp "ijProp")
(simp "ijProp")
(use "Truth")
(use "ijProp")
(use "ijProp")
;; Remaining two cases
(drop "KeyInst")
(assume "Disj")
(elim "Disj")

;; First the case for f
(drop "Disj")
(assume "ExjHyp")
(by-assume "ExjHyp" "j" "jProp")
(assert "f(Mini g n)<=f j")
 (use "NatLeTrans" (pt "Psi f g n"))
 (use "NatMaxUB1")
 (use "jProp")
(assume "f i<=f j")
(use "NatLeLtCases" (pt "g(Mini g n)") (pt "g j"))
;; Case "g i<=g j"
(assume "g i<=g j")
(intro 0)
(intro 0 (pt "Mini g n"))
(intro 0 (pt "j"))
(msplit)
(use "g i<=g j")
(use "f i<=f j")
(use "jProp")
(use "NatLeLtTrans" (pt "n"))
(use "Mini1")
(use "jProp")
;; Case "g j<g i"
(assume "g j<g i")
(intro 1)
(use "NatLeLtTrans" (pt "Phi f g j"))
(use "PhiAntiMon")
(use "jProp")
(ng #t)
(use "NatLtMonPlus2")
(use "fMiniAntiMon")
(use "NatLtToLe")
(use "jProp")
(use "NatLeLtTrans" (pt "g j"))
(use "Mini3")
(use "g j<g i")

;; Now the symmetric case with g for f
(drop "Disj")
(assume "ExjHyp")
(by-assume "ExjHyp" "j" "jProp")
(assert "g(Mini f n)<=g j")
 (use "NatLeTrans" (pt "Psi f g n"))
 (use "NatMaxUB2")
 (use "jProp")
(assume "g i<=g j")
(use "NatLeLtCases" (pt "f(Mini f n)") (pt "f j"))
;; Case "f i<=f j"
(assume "f i<=f j")
(intro 0)
(intro 0 (pt "Mini f n"))
(intro 0 (pt "j"))
(msplit)
(use "g i<=g j")
(use "f i<=f j")
(use "jProp")
(use "NatLeLtTrans" (pt "n"))
(use "Mini1")
(use "jProp")
;; Case "f j<f i"
(assume "f j<f i")
(intro 1)
(use "NatLeLtTrans" (pt "Phi f g j"))
(use "PhiAntiMon")
(use "jProp")
(ng #t)
(simp "NatPlusComm")
(assert "f(Mini f n)+g(Mini g n)=g(Mini g n)+f(Mini f n)")
 (use "NatPlusComm")
(assume "EqHyp")
(simp "EqHyp")
(use "NatLtMonPlus2")
(use "fMiniAntiMon")
(use "NatLtToLe")
(use "jProp")
(use "NatLeLtTrans" (pt "f j"))
(use "Mini3")
(use "f j<f i")
;; Proof finished.
(save "Desc")

;; With extraction:
;; DL
(set-goal "all f,g,n ex k(
 I f g n<=k & exu i,j(i<j & j<=k & f i<=f j & g i<=g j))")
(assume "f" "g")
(gind (pt "[n]Phi f g n"))
(assume "n" "IH")
(inst-with-to "Desc" (pt "f") (pt "g") (pt "n") "DescInst")
(elim "DescInst")
(assume "ExHyp")
(by-assume "ExHyp" "i" "iProp")
(by-assume "iProp" "j" "ijProp")
(ex-intro (pt "I f g n"))
(split)
(use "Truth")
(intro 0 (pt "i"))
(intro 0 (pt "j"))
(msplit)
(use "ijProp")
(use "ijProp")
(use "ijProp")
(use "ijProp")

(assume "LtHyp")
(drop "DescInst")
(inst-with-to "IH" (pt "I f g n") "IHInst")
(drop "IH")
(inst-with-to "IHInst" "LtHyp" "IHInstInst")
(drop "IHInst")
(by-assume "IHInstInst" "k" "kProp")
(ex-intro (pt "k"))
(split)
(use "NatLeTrans" (pt "I f g(I f g n)"))
(use "LeIncrI")
(use "kProp")
(use "kProp")
;; Proof finished.
(save "DL")

(define eterm (proof-to-extracted-term (theorem-name-to-proof "DL")))
(remove-computation-rules-for (pt "Phi f g n"))
(remove-computation-rules-for (pt "I f g n"))
(set! GRECGUARD-UNFOLDING-FLAG #f)

(define neterm (rename-variables (nt eterm)))
(pp neterm)
;; [f,f0,n]
;;  (GRecGuard nat nat)(Phi f f0)n
;;  ([n0,f1][if (cDesc f f0 n0) (I f f0 n0) (f1(I f f0 n0))])
;;  True

(add-computation-rule "Phi f g n" "f(Mini f n)+g(Mini g n)")
(add-computation-rule "I f g n" "Succ(n+Psi f g n*Psi f g n)")

;; L2
(set-goal "all f,g,n(
 exu i,j(i<j & j<=ItI f g n 0 & f i<=f j & g i<=g j) ori
 Phi f g(ItI f g n 0)+n<=f 0+g 0)")
(assume "f" "g")
(ind)
;; Base
(intro 1)
(use "Truth")
;; Step
(assume "n" "IH")
(assert "exu i,j(i<j & j<=ItI f g(Succ n)0 & f i<=f j & g i<=g j) ori
  Phi f g(ItI f g(Succ n)0)<Phi f g(ItI f g n 0)")
 (use "Desc")
(assume "OrHyp")
(elim "OrHyp")
(assume "DLISn")
(intro 0)
(use "DLISn")
(assume "LtHyp")
(elim "IH")
(assume "DLIn")
(intro 0)
(by-assume "DLIn" "i" "iProp")
(by-assume "iProp" "j" "ijProp")
(intro 0 (pt "i"))
(intro 0 (pt "j"))
(msplit)
(use "ijProp")
(use "ijProp")
(use "NatLeTrans" (pt "ItI f g n 0"))
(use "ijProp")
(use "LeMonItI")
(use "ijProp")
(assume "LeHyp")
(intro 1)
(use "NatLtSuccToLe")
(use "NatLtLeTrans" (pt "Phi f g(ItI f g n 0)+Succ n"))
(assert "all n1,n2(n1<n2 -> all n n1+n<n2+n)")
 (assume "n1" "n2" "n1<n2")
 (ind)
 (use "n1<n2")
 (assume "n3" "IHn3")
 (use "IHn3")
(assume "LtPlusMon")
(use "LtPlusMon")
(drop "LtPlusMon")
(use "LtHyp")
(use "LeHyp")
;; Proof finished.
(save "L2")

;; Dickson
(set-goal
 "all f,g exu i,j(i<j & j<=ItI f g(Succ(f 0+g 0))0 & f i<=f j & g i<=g j)")
(assume "f" "g")
(inst-with-to "L2" (pt "f") (pt "g") (pt "Succ(f 0+g 0)") "L2Inst")
(elim "L2Inst")
(drop "L2Inst")
(assume "ExHyp")
(use "ExHyp")
(assume "Absurd")
(use "Efq")
(drop "L2Inst")
(assert "Phi f g(ItI f g(Succ(f 0+g 0))0)+Succ(f 0+g 0)<Succ(f 0+g 0)")
 (use "NatLeToLtSucc")
 (use "Absurd")
(assume "Absurd1")
(assert "all nat1,nat2(nat1+nat2<nat2 -> F)")
 (ind)
 (assume "nat2" "Hyp")
 (use "Hyp")
 (assume "nat1" "IH")
 (cases)
 (assume "Hyp")
 (use "Hyp")
 (assume "nat2")
 (ng #t)
 (assume "Succ(nat1+nat2)<nat2")
 (use "IH" (pt "nat2"))
 (use "NatLtTrans" (pt "Succ(nat1+nat2)"))
 (use "Truth")
 (use "Succ(nat1+nat2)<nat2")
(assume "NatNotSumLtSecond")
(use "NatNotSumLtSecond"
     (pt "Phi f g(ItI f g(Succ(f 0+g 0))0)") (pt "Succ(f 0+g 0)"))
(use "Absurd1")
;; Proof finished.
(save "Dickson")
